<!DOCTYPE html>
<!--[if IE]><![endif]-->
<html>
  
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>Using paging | PnP Core SDK </title>
    <meta name="viewport" content="width=device-width">
    <meta name="title" content="Using paging | PnP Core SDK ">
    <meta name="generator" content="docfx 2.51.0.0">
    
    <link rel="shortcut icon" href="../../https://c.s-microsoft.com/favicon.ico?v2">
    <link rel="stylesheet" href="../../styles/docfx.vendor.css">
    <link rel="stylesheet" href="../../styles/docfx.css">
    <link rel="stylesheet" href="../../styles/main.css">
    <meta property="docfx:navrel" content="../../toc.html">
    <meta property="docfx:tocrel" content="../toc.html">
    
    <meta property="docfx:rel" content="../../">
    <meta property="docfx:newtab" content="true">
  </head>
  <body data-spy="scroll" data-target="#affix" data-offset="120">
    <div id="wrapper">
      <header>
        
        <nav id="autocollapse" class="navbar navbar-inverse ng-scope" role="navigation">
          <div class="container">
            <div class="navbar-header">
              <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navbar">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>
              
              <a class="navbar-brand" href="../../index.html">
                <img id="logo" class="svg" src="../../logo.svg" alt="">
              </a>
            </div>
            <div class="collapse navbar-collapse" id="navbar">
              <form class="navbar-form navbar-right" role="search" id="search">
                <div class="form-group">
                  <input type="text" class="form-control" id="search-query" placeholder="Search" autocomplete="off">
                </div>
              </form>
            </div>
          </div>
        </nav>
        
        <div class="subnav navbar navbar-default">
          <div class="container hide-when-search" id="breadcrumb">
            <ul class="breadcrumb">
              <li></li>
            </ul>
          </div>
        </div>
      </header>
      <div class="container body-content">
        
        <div id="search-results">
          <div class="search-list"></div>
          <div class="sr-items">
            <p><i class="glyphicon glyphicon-refresh index-loading"></i></p>
          </div>
          <ul id="pagination"></ul>
        </div>
      </div>
      <div role="main" class="container body-content hide-when-search">
        
        <div class="sidenav hide-when-search">
          <a class="btn toc-toggle collapse" data-toggle="collapse" href="#sidetoggle" aria-expanded="false" aria-controls="sidetoggle">Show / Hide Table of Contents</a>
          <div class="sidetoggle collapse" id="sidetoggle">
            <div id="sidetoc"></div>
          </div>
        </div>
        <div class="article row grid-right">
          <div class="col-md-10">
            <article class="content wrap" id="_content" data-uid="">
<h1 id="using-paging">Using paging</h1>

<p>Being able to retrieve data in a paged manner is important when you want to use the first data rows while you're loading still additional data, but also when you're loading large data sets. When you page data you can start from either a <code>GetPagedAsync()</code> method call or from a linq query that uses the <code>Take()</code> method. Once you've done one of these calls to Microsoft 365 can use the paging methods to get additional pages.</p>
<h2 id="supported-paging-attributes-and-methods">Supported paging attributes and methods</h2>
<table>
<thead>
<tr>
<th>Method/Attribute</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>GetPagedAsync(pageSize, expression)</code></td>
<td>Loads the first page of a given size. Optionally an expression can be specified to only return the properties you need</td>
</tr>
<tr>
<td><code>CanPage</code></td>
<td>This attribute indicates whether you can use the paging API's to request a next page or to request all remaining pages</td>
</tr>
<tr>
<td><code>GetNextPageAsync()</code></td>
<td>Get's the next page, this method assumes you've already loaded a first page using either the <code>GetPagedAsync()</code> method or via a linq query that included the <code>Take()</code> method</td>
</tr>
<tr>
<td><code>GetAllPagesAsync()</code></td>
<td>Loads all the pages in a collection until there's no new data returned anymore. This method assumes you've already loaded a first page using either the <code>GetPagedAsync()</code> method or via a linq query that included the <code>Take()</code> method</td>
</tr>
</tbody>
</table>
<h2 id="examples">Examples</h2>
<h3 id="starting-via-the-getpagedasync-method">Starting via the GetPagedAsync() method</h3>
<p>This example shows how to use paging to load lists, in the sample only the <code>Title</code> property of the list is requested, if you do not provide the expression then list default properties are loaded.</p>
<pre><code class="lang-csharp">using (var context = pnpContextFactory.Create(&quot;SiteToWorkWith&quot;))
{
    // Get a first page of lists of size 2
    await context.Web.Lists.GetPagedAsync(2, p =&gt; p.Title);

    // Do we have a pointer to a next page?
    if (context.Web.Lists.CanPage)
    {
        // Load the next page
        await context.Web.Lists.GetNextPageAsync();

        // Load all pages
        await context.Web.Lists.GetAllPagesAsync();
    }
}
</code></pre>
<h3 id="starting-via-a-linq-query-with-take">Starting via a linq query with Take()</h3>
<p>In this example a linq query is executed first using the <code>Take()</code> method. Once the linq query was execution was triggered (in this case by calling <code>ToList()</code>), you can using the paging methods to get additional pages of data.</p>
<pre><code class="lang-csharp">using (var context = pnpContextFactory.Create(&quot;SiteToWorkWith&quot;))
{
    // Issue a linq query
    var lists = context.Web.Lists.Take(2);
    var queryResult = lists.ToList();

    // Do we have a pointer to a next page?
    if (context.Web.Lists.CanPage)
    {
        // Load the next page
        await context.Web.Lists.GetNextPageAsync();

        // Load all pages
        await context.Web.Lists.GetAllPagesAsync();
    }
}
</code></pre>
</article>
          </div>
          <div class="contribution-panel mobile-hide">
              <a href="https://github.com/pnp/pnpcore/blob/dev/docs/articles/consumer/using paging.md/#L1" title="Improve this Doc" class="fab btn-warning pull-right"><i class="glyphicon glyphicon-pencil"></i></a>
          </div>
          
          <div class="hidden-sm col-md-2" role="complementary">
            <div class="sideaffix">
              <nav class="bs-docs-sidebar hidden-print hidden-xs hidden-sm affix" id="affix">
              </nav>
            </div>
          </div>        </div>
      </div>
      
      <footer>
        <div class="grad-bottom"></div>
        <div class="footer">
          <div class="container">
            <span class="pull-right">
              <a href="#top">Back to top</a>
            </span>
            PnP Core SDK
            
          </div>
        </div>
      </footer>
    </div>
    
    <script type="text/javascript" src="../../styles/docfx.vendor.js"></script>
    <script type="text/javascript" src="../../styles/docfx.js"></script>
    <script type="text/javascript" src="../../styles/main.js"></script>
  </body>
</html>
