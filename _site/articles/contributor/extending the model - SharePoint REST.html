<!DOCTYPE html>
<!--[if IE]><![endif]-->
<html>
  
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>Extending the model for SharePoint REST | PnP Core SDK </title>
    <meta name="viewport" content="width=device-width">
    <meta name="title" content="Extending the model for SharePoint REST | PnP Core SDK ">
    <meta name="generator" content="docfx 2.52.0.0">
    
    <link rel="shortcut icon" href="../../https://c.s-microsoft.com/favicon.ico?v2">
    <link rel="stylesheet" href="../../styles/docfx.vendor.css">
    <link rel="stylesheet" href="../../styles/docfx.css">
    <link rel="stylesheet" href="../../styles/main.css">
    <meta property="docfx:navrel" content="../../toc.html">
    <meta property="docfx:tocrel" content="../toc.html">
    
    <meta property="docfx:rel" content="../../">
    <meta property="docfx:newtab" content="true">
  </head>
  <body data-spy="scroll" data-target="#affix" data-offset="120">
    <div id="wrapper">
      <header>
        
        <nav id="autocollapse" class="navbar navbar-inverse ng-scope" role="navigation">
          <div class="container">
            <div class="navbar-header">
              <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navbar">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>
              
              <a class="navbar-brand" href="../../index.html">
                <img id="logo" class="svg" src="../../logo.svg" alt="">
              </a>
            </div>
            <div class="collapse navbar-collapse" id="navbar">
              <form class="navbar-form navbar-right" role="search" id="search">
                <div class="form-group">
                  <input type="text" class="form-control" id="search-query" placeholder="Search" autocomplete="off">
                </div>
              </form>
            </div>
          </div>
        </nav>
        
        <div class="subnav navbar navbar-default">
          <div class="container hide-when-search" id="breadcrumb">
            <ul class="breadcrumb">
              <li></li>
            </ul>
          </div>
        </div>
      </header>
      <div class="container body-content">
        
        <div id="search-results">
          <div class="search-list"></div>
          <div class="sr-items">
            <p><i class="glyphicon glyphicon-refresh index-loading"></i></p>
          </div>
          <ul id="pagination"></ul>
        </div>
      </div>
      <div role="main" class="container body-content hide-when-search">
        
        <div class="sidenav hide-when-search">
          <a class="btn toc-toggle collapse" data-toggle="collapse" href="#sidetoggle" aria-expanded="false" aria-controls="sidetoggle">Show / Hide Table of Contents</a>
          <div class="sidetoggle collapse" id="sidetoggle">
            <div id="sidetoc"></div>
          </div>
        </div>
        <div class="article row grid-right">
          <div class="col-md-10">
            <article class="content wrap" id="_content" data-uid="">
<h1 id="extending-the-model-for-sharepoint-rest">Extending the model for SharePoint REST</h1>

<p>The PnP Core SDK model contains model, collection and complex type classes which are populated via either Microsoft Graph and/or SharePoint REST. In this chapter you'll learn more on how to decorate your classes and their properties to interact with Microsoft 365 via the SharePoint REST API.</p>
<h2 id="configuring-model-classes">Configuring model classes</h2>
<h3 id="public-model-interface-decoration">Public model (interface) decoration</h3>
<p>For model classes that <strong>are linq queriable</strong> one needs to to link the concrete (so the implementation) to the public interface via the <code>ConcreteType</code> class attribute:</p>
<pre><code class="lang-csharp">[ConcreteType(typeof(List))]
public interface IList : IDataModel&lt;IList&gt;, IDataModelUpdate, IDataModelDelete
{
    // Ommitted for brevity
}
</code></pre>
<h3 id="class-decoration">Class decoration</h3>
<p>Each model class that uses SharePoint REST does need to have a <code>SharePointType</code> attribute which is defined on the coded model class (e.g. List.cs):</p>
<pre><code class="lang-csharp">[SharePointType(&quot;SP.List&quot;, Uri = &quot;_api/Web/Lists(guid'{Id}')&quot;, Get = &quot;_api/web/lists&quot;, Update = &quot;_api/web/lists/getbyid(guid'{Id}')&quot;, LinqGet = &quot;_api/web/lists&quot;)]
internal partial class List
{
    // Ommitted for brevity
}
</code></pre>
<p>When configuring the <code>SharePointType</code> attribute for SharePoint REST you need to set attribute properties:</p>
<table>
<thead>
<tr>
<th>Property</th>
<th>Required</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>Type</td>
<td>Yes</td>
<td>Defines the SharePoint REST type that maps with the model class. Each model that requires SharePoint REST requires this attribute, hence the type is requested via the attribute constructor.</td>
</tr>
<tr>
<td>Uri</td>
<td>Yes</td>
<td>Defines the URI that uniquely identifies this object. See <a href="model%20tokens.html">model tokens</a> to learn more about the possible tokens you can use.</td>
</tr>
<tr>
<td>Get</td>
<td>No</td>
<td>Overrides the Uri property for <strong>get</strong> operations.</td>
</tr>
<tr>
<td>LinqGet</td>
<td>No</td>
<td>Some model classes do support linq queries which are translated in corresponding server calls. If a class supports linq in this way, then it also needs to have the LinqGet attribute set.</td>
</tr>
<tr>
<td>Update</td>
<td>No</td>
<td>Overrides the Uri property for <strong>update</strong> operations.</td>
</tr>
<tr>
<td>Delete</td>
<td>No</td>
<td>Overrides the Uri property for <strong>delete</strong> operations.</td>
</tr>
<tr>
<td>OverflowProperty</td>
<td>No</td>
<td>Used when working with a dynamic property/value pair (e.g. fields in a SharePoint ListItem) whenever the SharePoint REST field containing these dynamic properties is not named <code>Values</code>.</td>
</tr>
</tbody>
</table>
<h3 id="property-decoration">Property decoration</h3>
<p>The property level decoration is done using the <code>SharePointProperty</code> and <code>KeyProperty</code> attributes. Each model instance does require to have a override of the <code>Key</code> property and that <code>Key</code> property <strong>must</strong> be decorated with the <code>KeyProperty</code> attribute which specifies which of the actual fields in the model must be selected as key. The key is for example used to ensure there are no duplicate model class instances in a single collection.</p>
<p>Whereas the <code>KeyProperty</code> attribute is always there once in each model class, the usage of the <code>SharePointProperty</code> attribute is only needed whenever it makes sense. For most properties you do not need to set this attribute, it's only required for special cases. Since the properties are defined in the generated model class (e.g. List.gen.cs) the decoration via attributes needs to happen in this class as well.</p>
<pre><code class="lang-csharp">// Configure the SharePoint REST field used to populate this model property
[SharePointProperty(&quot;DocumentTemplateUrl&quot;)]
public string DocumentTemplate { get =&gt; GetValue&lt;string&gt;(); set =&gt; SetValue(value); }

// Define a collection as expandable
[SharePointProperty(&quot;Items&quot;, Expandable = true)]
public IListItemCollection Items
{
    get
    {
        if (!HasValue(nameof(Items)))
        {
            var items = new ListItemCollection
            {
                PnPContext = this.PnPContext,
                Parent = this
            };
            SetValue(items);
        }
        return GetValue&lt;IListItemCollection&gt;();
    }
}

// Set the keyfield for this model class
[KeyProperty(&quot;Id&quot;)]
public override object Key { get =&gt; this.Id; set =&gt; this.Id = Guid.Parse(value.ToString()); }
</code></pre>
<p>You can set following properties on this attribute:</p>
<table>
<thead>
<tr>
<th>Property</th>
<th>Required</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>FieldName</td>
<td>Yes</td>
<td>Use this property when the SharePoint REST fieldname differs from the model property name, since the field name is required by the default constructor you always need to provide this value when you add this property</td>
</tr>
<tr>
<td>JsonPath</td>
<td>No</td>
<td>When the information returned from SharePoint REST is a complex type and you only need a single value from it, then you can specify the JsonPath for that value. E.g. when you get sharePointIds.webId as response you tell the model that the fieldname is sharePointIds and the path to get there is webId. The path can be more complex, using a point to define property you need (e.g. property.child.childofchild)</td>
</tr>
<tr>
<td>Expandable</td>
<td>No</td>
<td>Defines that a collection is expandable, meaning it can be loaded via the $expand query parameter and used in the lambda expression in <code>Get</code> and <code>GetAsync</code> operations</td>
</tr>
<tr>
<td>ExpandByDefault</td>
<td>No</td>
<td>When the model contains a collection of other model objects then setting this attribute to true will automatically result in the population of that collection. This can negatively impact performance, so only set this when the collection is almost always needed</td>
</tr>
<tr>
<td>UseCustomMapping</td>
<td>No</td>
<td>Allows you to force a callout to the model's <code>MappingHandler</code> event handler whenever this property is populated. See the <a href="event%20handlers.html">Event Handlers</a> article to learn more</td>
</tr>
</tbody>
</table>
<h2 id="configuring-complex-type-classes">Configuring complex type classes</h2>
<p>Complex type classes are not used when the model is populated via SharePoint REST.</p>
<h2 id="configuring-collection-classes">Configuring collection classes</h2>
<p>Collection classes <strong>do not</strong> have attribute based decoration.</p>
<h2 id="implementing-add-functionality">Implementing &quot;Add&quot; functionality</h2>
<p>In contradiction with get, update and delete which are fully handled by decorating classes and properties using attributes, you'll need to write actual code to implement add. Adding is implemented as follows:</p>
<ul>
<li><p>The public part (interface) is defined on the collection interface. Each functionality (like Add) is implemented via three methods:</p>
<ul>
<li>An async method</li>
<li>A regular method</li>
<li>A regular method that allows to pass in a <code>Batch</code> as first method parameter</li>
</ul>
</li>
<li><p>Add methods defined on the interface are implemented in the collection classes as a proxies that call into the respective add methods of the added model class</p>
</li>
<li><p>The implementation that performs the actual add is implemented as an <code>AddApiCallHandler</code> event handler in the model class. See the <a href="event%20handlers.html">Event Handlers</a> page for more details.</p>
</li>
</ul>
<p>Below code snippets show the above three concepts. First one shows the collection interface (e.g. IListCollection.cs) with the Add methods:</p>
<pre><code class="lang-csharp">/// &lt;summary&gt;
/// Public interface to define a collection of List objects of SharePoint Online
/// &lt;/summary&gt;
public interface IListCollection : IQueryable&lt;IList&gt;, IDataModelCollection&lt;IList&gt;, ISupportPaging
{
    /// &lt;summary&gt;
    /// Adds a new list
    /// &lt;/summary&gt;
    /// &lt;param name=&quot;title&quot;&gt;Title of the list&lt;/param&gt;
    /// &lt;param name=&quot;templateType&quot;&gt;Template type&lt;/param&gt;
    /// &lt;returns&gt;Newly added list&lt;/returns&gt;
    public Task&lt;IList&gt; AddAsync(string title, int templateType);

    /// &lt;summary&gt;
    /// Adds a new list
    /// &lt;/summary&gt;
    /// &lt;param name=&quot;batch&quot;&gt;Batch to use&lt;/param&gt;
    /// &lt;param name=&quot;title&quot;&gt;Title of the list&lt;/param&gt;
    /// &lt;param name=&quot;templateType&quot;&gt;Template type&lt;/param&gt;
    /// &lt;returns&gt;Newly added list&lt;/returns&gt;
    public IList Add(Batch batch, string title, int templateType);

    /// &lt;summary&gt;
    /// Adds a new list
    /// &lt;/summary&gt;
    /// &lt;param name=&quot;title&quot;&gt;Title of the list&lt;/param&gt;
    /// &lt;param name=&quot;templateType&quot;&gt;Template type&lt;/param&gt;
    /// &lt;returns&gt;Newly added list&lt;/returns&gt;
    public IList Add(string title, int templateType);
}
</code></pre>
<p>Implementation of the interface in the coded collection class (e.g. ListCollection.cs):</p>
<pre><code class="lang-csharp">internal partial class ListCollection
{
    public IList Add(string title, int templateType)
    {
        return Add(PnPContext.CurrentBatch, title, templateType);
    }

    public IList Add(Batch batch, string title, int templateType)
    {
        if (title == null)
        {
            throw new ArgumentNullException(nameof(title));
        }

        if (templateType == 0)
        {
            throw new ArgumentException($&quot;{nameof(templateType)} cannot be 0&quot;);
        }

        var newList = AddNewList();

        newList.Title = title;
        newList.TemplateType = templateType;

        return newList.Add(batch) as List;
    }

    public async Task&lt;IList&gt; AddAsync(string title, int templateType)
    {
        if (title == null)
        {
            throw new ArgumentNullException(nameof(title));
        }

        if (templateType == 0)
        {
            throw new ArgumentException($&quot;{nameof(templateType)} cannot be 0&quot;);
        }

        var newList = AddNewList();

        newList.Title = title;
        newList.TemplateType = templateType;

        return await newList.AddAsync().ConfigureAwait(false) as List;
    }
}
</code></pre>
<p>And finally you'll see the actual add logic being implemented in the coded model class (e.g. List.cs) via implementing the <code>AddApiCallHandler</code>:</p>
<pre><code class="lang-csharp">internal partial class List
{
    /// &lt;summary&gt;
    /// Class to model the Rest List Add request
    /// &lt;/summary&gt;
    internal class ListAdd: RestBaseAdd&lt;IList&gt;
    {
        public int BaseTemplate { get; set; }

        public string Title { get; set; }

        internal ListAdd(BaseDataModel&lt;IList&gt; model, int templateType, string title) : base(model)
        {
            BaseTemplate = templateType;
            Title = title;
        }
    }

    internal List()
    {
        // Handler to construct the Add request for this list
        AddApiCallHandler = () =&gt;
        {
            return new ApiCall($&quot;_api/web/lists&quot;, ApiType.Rest, JsonSerializer.Serialize(new ListAdd(this, TemplateType, Title)));
        };
    }
}
</code></pre>
</article>
          </div>
          <div class="contribution-panel mobile-hide">
              <a href="https://github.com/pnp/pnpcore/blob/dev/docs/articles/contributor/extending the model - SharePoint REST.md/#L1" title="Improve this Doc" class="fab btn-warning pull-right"><i class="glyphicon glyphicon-pencil"></i></a>
          </div>
          
          <div class="hidden-sm col-md-2" role="complementary">
            <div class="sideaffix">
              <nav class="bs-docs-sidebar hidden-print hidden-xs hidden-sm affix" id="affix">
              </nav>
            </div>
          </div>        </div>
      </div>
      
      <footer>
        <div class="grad-bottom"></div>
        <div class="footer">
          <div class="container">
            <span class="pull-right">
              <a href="#top">Back to top</a>
            </span>
            PnP Core SDK
            
          </div>
        </div>
      </footer>
    </div>
    
    <script type="text/javascript" src="../../styles/docfx.vendor.js"></script>
    <script type="text/javascript" src="../../styles/docfx.js"></script>
    <script type="text/javascript" src="../../styles/main.js"></script>
  </body>
</html>
